<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<style type="text/css">
pre { white-space: pre-wrap; }
.ef0,.f0 { color: #000000; } .eb0,.b0 { background-color: #000000; }
.ef1,.f1 { color: #AA0000; } .eb1,.b1 { background-color: #AA0000; }
.ef2,.f2 { color: #00AA00; } .eb2,.b2 { background-color: #00AA00; }
.ef3,.f3 { color: #AA5500; } .eb3,.b3 { background-color: #AA5500; }
.ef4,.f4 { color: #0000AA; } .eb4,.b4 { background-color: #0000AA; }
.ef5,.f5 { color: #AA00AA; } .eb5,.b5 { background-color: #AA00AA; }
.ef6,.f6 { color: #00AAAA; } .eb6,.b6 { background-color: #00AAAA; }
.ef7,.f7 { color: #AAAAAA; } .eb7,.b7 { background-color: #AAAAAA; }
.ef8, .f0 > .bold,.bold > .f0 { color: #555555; font-weight: normal; }
.ef9, .f1 > .bold,.bold > .f1 { color: #FF5555; font-weight: normal; }
.ef10,.f2 > .bold,.bold > .f2 { color: #55FF55; font-weight: normal; }
.ef11,.f3 > .bold,.bold > .f3 { color: #FFFF55; font-weight: normal; }
.ef12,.f4 > .bold,.bold > .f4 { color: #5555FF; font-weight: normal; }
.ef13,.f5 > .bold,.bold > .f5 { color: #FF55FF; font-weight: normal; }
.ef14,.f6 > .bold,.bold > .f6 { color: #55FFFF; font-weight: normal; }
.ef15,.f7 > .bold,.bold > .f7 { color: #FFFFFF; font-weight: normal; }
.eb8  { background-color: #555555; }
.eb9  { background-color: #FF5555; }
.eb10 { background-color: #55FF55; }
.eb11 { background-color: #FFFF55; }
.eb12 { background-color: #5555FF; }
.eb13 { background-color: #FF55FF; }
.eb14 { background-color: #55FFFF; }
.eb15 { background-color: #FFFFFF; }
.ef16 { color: #000000; } .eb16 { background-color: #000000; }
.ef17 { color: #00005f; } .eb17 { background-color: #00005f; }
.ef18 { color: #000087; } .eb18 { background-color: #000087; }
.ef19 { color: #0000af; } .eb19 { background-color: #0000af; }
.ef20 { color: #0000d7; } .eb20 { background-color: #0000d7; }
.ef21 { color: #0000ff; } .eb21 { background-color: #0000ff; }
.ef22 { color: #005f00; } .eb22 { background-color: #005f00; }
.ef23 { color: #005f5f; } .eb23 { background-color: #005f5f; }
.ef24 { color: #005f87; } .eb24 { background-color: #005f87; }
.ef25 { color: #005faf; } .eb25 { background-color: #005faf; }
.ef26 { color: #005fd7; } .eb26 { background-color: #005fd7; }
.ef27 { color: #005fff; } .eb27 { background-color: #005fff; }
.ef28 { color: #008700; } .eb28 { background-color: #008700; }
.ef29 { color: #00875f; } .eb29 { background-color: #00875f; }
.ef30 { color: #008787; } .eb30 { background-color: #008787; }
.ef31 { color: #0087af; } .eb31 { background-color: #0087af; }
.ef32 { color: #0087d7; } .eb32 { background-color: #0087d7; }
.ef33 { color: #0087ff; } .eb33 { background-color: #0087ff; }
.ef34 { color: #00af00; } .eb34 { background-color: #00af00; }
.ef35 { color: #00af5f; } .eb35 { background-color: #00af5f; }
.ef36 { color: #00af87; } .eb36 { background-color: #00af87; }
.ef37 { color: #00afaf; } .eb37 { background-color: #00afaf; }
.ef38 { color: #00afd7; } .eb38 { background-color: #00afd7; }
.ef39 { color: #00afff; } .eb39 { background-color: #00afff; }
.ef40 { color: #00d700; } .eb40 { background-color: #00d700; }
.ef41 { color: #00d75f; } .eb41 { background-color: #00d75f; }
.ef42 { color: #00d787; } .eb42 { background-color: #00d787; }
.ef43 { color: #00d7af; } .eb43 { background-color: #00d7af; }
.ef44 { color: #00d7d7; } .eb44 { background-color: #00d7d7; }
.ef45 { color: #00d7ff; } .eb45 { background-color: #00d7ff; }
.ef46 { color: #00ff00; } .eb46 { background-color: #00ff00; }
.ef47 { color: #00ff5f; } .eb47 { background-color: #00ff5f; }
.ef48 { color: #00ff87; } .eb48 { background-color: #00ff87; }
.ef49 { color: #00ffaf; } .eb49 { background-color: #00ffaf; }
.ef50 { color: #00ffd7; } .eb50 { background-color: #00ffd7; }
.ef51 { color: #00ffff; } .eb51 { background-color: #00ffff; }
.ef52 { color: #5f0000; } .eb52 { background-color: #5f0000; }
.ef53 { color: #5f005f; } .eb53 { background-color: #5f005f; }
.ef54 { color: #5f0087; } .eb54 { background-color: #5f0087; }
.ef55 { color: #5f00af; } .eb55 { background-color: #5f00af; }
.ef56 { color: #5f00d7; } .eb56 { background-color: #5f00d7; }
.ef57 { color: #5f00ff; } .eb57 { background-color: #5f00ff; }
.ef58 { color: #5f5f00; } .eb58 { background-color: #5f5f00; }
.ef59 { color: #5f5f5f; } .eb59 { background-color: #5f5f5f; }
.ef60 { color: #5f5f87; } .eb60 { background-color: #5f5f87; }
.ef61 { color: #5f5faf; } .eb61 { background-color: #5f5faf; }
.ef62 { color: #5f5fd7; } .eb62 { background-color: #5f5fd7; }
.ef63 { color: #5f5fff; } .eb63 { background-color: #5f5fff; }
.ef64 { color: #5f8700; } .eb64 { background-color: #5f8700; }
.ef65 { color: #5f875f; } .eb65 { background-color: #5f875f; }
.ef66 { color: #5f8787; } .eb66 { background-color: #5f8787; }
.ef67 { color: #5f87af; } .eb67 { background-color: #5f87af; }
.ef68 { color: #5f87d7; } .eb68 { background-color: #5f87d7; }
.ef69 { color: #5f87ff; } .eb69 { background-color: #5f87ff; }
.ef70 { color: #5faf00; } .eb70 { background-color: #5faf00; }
.ef71 { color: #5faf5f; } .eb71 { background-color: #5faf5f; }
.ef72 { color: #5faf87; } .eb72 { background-color: #5faf87; }
.ef73 { color: #5fafaf; } .eb73 { background-color: #5fafaf; }
.ef74 { color: #5fafd7; } .eb74 { background-color: #5fafd7; }
.ef75 { color: #5fafff; } .eb75 { background-color: #5fafff; }
.ef76 { color: #5fd700; } .eb76 { background-color: #5fd700; }
.ef77 { color: #5fd75f; } .eb77 { background-color: #5fd75f; }
.ef78 { color: #5fd787; } .eb78 { background-color: #5fd787; }
.ef79 { color: #5fd7af; } .eb79 { background-color: #5fd7af; }
.ef80 { color: #5fd7d7; } .eb80 { background-color: #5fd7d7; }
.ef81 { color: #5fd7ff; } .eb81 { background-color: #5fd7ff; }
.ef82 { color: #5fff00; } .eb82 { background-color: #5fff00; }
.ef83 { color: #5fff5f; } .eb83 { background-color: #5fff5f; }
.ef84 { color: #5fff87; } .eb84 { background-color: #5fff87; }
.ef85 { color: #5fffaf; } .eb85 { background-color: #5fffaf; }
.ef86 { color: #5fffd7; } .eb86 { background-color: #5fffd7; }
.ef87 { color: #5fffff; } .eb87 { background-color: #5fffff; }
.ef88 { color: #870000; } .eb88 { background-color: #870000; }
.ef89 { color: #87005f; } .eb89 { background-color: #87005f; }
.ef90 { color: #870087; } .eb90 { background-color: #870087; }
.ef91 { color: #8700af; } .eb91 { background-color: #8700af; }
.ef92 { color: #8700d7; } .eb92 { background-color: #8700d7; }
.ef93 { color: #8700ff; } .eb93 { background-color: #8700ff; }
.ef94 { color: #875f00; } .eb94 { background-color: #875f00; }
.ef95 { color: #875f5f; } .eb95 { background-color: #875f5f; }
.ef96 { color: #875f87; } .eb96 { background-color: #875f87; }
.ef97 { color: #875faf; } .eb97 { background-color: #875faf; }
.ef98 { color: #875fd7; } .eb98 { background-color: #875fd7; }
.ef99 { color: #875fff; } .eb99 { background-color: #875fff; }
.ef100 { color: #878700; } .eb100 { background-color: #878700; }
.ef101 { color: #87875f; } .eb101 { background-color: #87875f; }
.ef102 { color: #878787; } .eb102 { background-color: #878787; }
.ef103 { color: #8787af; } .eb103 { background-color: #8787af; }
.ef104 { color: #8787d7; } .eb104 { background-color: #8787d7; }
.ef105 { color: #8787ff; } .eb105 { background-color: #8787ff; }
.ef106 { color: #87af00; } .eb106 { background-color: #87af00; }
.ef107 { color: #87af5f; } .eb107 { background-color: #87af5f; }
.ef108 { color: #87af87; } .eb108 { background-color: #87af87; }
.ef109 { color: #87afaf; } .eb109 { background-color: #87afaf; }
.ef110 { color: #87afd7; } .eb110 { background-color: #87afd7; }
.ef111 { color: #87afff; } .eb111 { background-color: #87afff; }
.ef112 { color: #87d700; } .eb112 { background-color: #87d700; }
.ef113 { color: #87d75f; } .eb113 { background-color: #87d75f; }
.ef114 { color: #87d787; } .eb114 { background-color: #87d787; }
.ef115 { color: #87d7af; } .eb115 { background-color: #87d7af; }
.ef116 { color: #87d7d7; } .eb116 { background-color: #87d7d7; }
.ef117 { color: #87d7ff; } .eb117 { background-color: #87d7ff; }
.ef118 { color: #87ff00; } .eb118 { background-color: #87ff00; }
.ef119 { color: #87ff5f; } .eb119 { background-color: #87ff5f; }
.ef120 { color: #87ff87; } .eb120 { background-color: #87ff87; }
.ef121 { color: #87ffaf; } .eb121 { background-color: #87ffaf; }
.ef122 { color: #87ffd7; } .eb122 { background-color: #87ffd7; }
.ef123 { color: #87ffff; } .eb123 { background-color: #87ffff; }
.ef124 { color: #af0000; } .eb124 { background-color: #af0000; }
.ef125 { color: #af005f; } .eb125 { background-color: #af005f; }
.ef126 { color: #af0087; } .eb126 { background-color: #af0087; }
.ef127 { color: #af00af; } .eb127 { background-color: #af00af; }
.ef128 { color: #af00d7; } .eb128 { background-color: #af00d7; }
.ef129 { color: #af00ff; } .eb129 { background-color: #af00ff; }
.ef130 { color: #af5f00; } .eb130 { background-color: #af5f00; }
.ef131 { color: #af5f5f; } .eb131 { background-color: #af5f5f; }
.ef132 { color: #af5f87; } .eb132 { background-color: #af5f87; }
.ef133 { color: #af5faf; } .eb133 { background-color: #af5faf; }
.ef134 { color: #af5fd7; } .eb134 { background-color: #af5fd7; }
.ef135 { color: #af5fff; } .eb135 { background-color: #af5fff; }
.ef136 { color: #af8700; } .eb136 { background-color: #af8700; }
.ef137 { color: #af875f; } .eb137 { background-color: #af875f; }
.ef138 { color: #af8787; } .eb138 { background-color: #af8787; }
.ef139 { color: #af87af; } .eb139 { background-color: #af87af; }
.ef140 { color: #af87d7; } .eb140 { background-color: #af87d7; }
.ef141 { color: #af87ff; } .eb141 { background-color: #af87ff; }
.ef142 { color: #afaf00; } .eb142 { background-color: #afaf00; }
.ef143 { color: #afaf5f; } .eb143 { background-color: #afaf5f; }
.ef144 { color: #afaf87; } .eb144 { background-color: #afaf87; }
.ef145 { color: #afafaf; } .eb145 { background-color: #afafaf; }
.ef146 { color: #afafd7; } .eb146 { background-color: #afafd7; }
.ef147 { color: #afafff; } .eb147 { background-color: #afafff; }
.ef148 { color: #afd700; } .eb148 { background-color: #afd700; }
.ef149 { color: #afd75f; } .eb149 { background-color: #afd75f; }
.ef150 { color: #afd787; } .eb150 { background-color: #afd787; }
.ef151 { color: #afd7af; } .eb151 { background-color: #afd7af; }
.ef152 { color: #afd7d7; } .eb152 { background-color: #afd7d7; }
.ef153 { color: #afd7ff; } .eb153 { background-color: #afd7ff; }
.ef154 { color: #afff00; } .eb154 { background-color: #afff00; }
.ef155 { color: #afff5f; } .eb155 { background-color: #afff5f; }
.ef156 { color: #afff87; } .eb156 { background-color: #afff87; }
.ef157 { color: #afffaf; } .eb157 { background-color: #afffaf; }
.ef158 { color: #afffd7; } .eb158 { background-color: #afffd7; }
.ef159 { color: #afffff; } .eb159 { background-color: #afffff; }
.ef160 { color: #d70000; } .eb160 { background-color: #d70000; }
.ef161 { color: #d7005f; } .eb161 { background-color: #d7005f; }
.ef162 { color: #d70087; } .eb162 { background-color: #d70087; }
.ef163 { color: #d700af; } .eb163 { background-color: #d700af; }
.ef164 { color: #d700d7; } .eb164 { background-color: #d700d7; }
.ef165 { color: #d700ff; } .eb165 { background-color: #d700ff; }
.ef166 { color: #d75f00; } .eb166 { background-color: #d75f00; }
.ef167 { color: #d75f5f; } .eb167 { background-color: #d75f5f; }
.ef168 { color: #d75f87; } .eb168 { background-color: #d75f87; }
.ef169 { color: #d75faf; } .eb169 { background-color: #d75faf; }
.ef170 { color: #d75fd7; } .eb170 { background-color: #d75fd7; }
.ef171 { color: #d75fff; } .eb171 { background-color: #d75fff; }
.ef172 { color: #d78700; } .eb172 { background-color: #d78700; }
.ef173 { color: #d7875f; } .eb173 { background-color: #d7875f; }
.ef174 { color: #d78787; } .eb174 { background-color: #d78787; }
.ef175 { color: #d787af; } .eb175 { background-color: #d787af; }
.ef176 { color: #d787d7; } .eb176 { background-color: #d787d7; }
.ef177 { color: #d787ff; } .eb177 { background-color: #d787ff; }
.ef178 { color: #d7af00; } .eb178 { background-color: #d7af00; }
.ef179 { color: #d7af5f; } .eb179 { background-color: #d7af5f; }
.ef180 { color: #d7af87; } .eb180 { background-color: #d7af87; }
.ef181 { color: #d7afaf; } .eb181 { background-color: #d7afaf; }
.ef182 { color: #d7afd7; } .eb182 { background-color: #d7afd7; }
.ef183 { color: #d7afff; } .eb183 { background-color: #d7afff; }
.ef184 { color: #d7d700; } .eb184 { background-color: #d7d700; }
.ef185 { color: #d7d75f; } .eb185 { background-color: #d7d75f; }
.ef186 { color: #d7d787; } .eb186 { background-color: #d7d787; }
.ef187 { color: #d7d7af; } .eb187 { background-color: #d7d7af; }
.ef188 { color: #d7d7d7; } .eb188 { background-color: #d7d7d7; }
.ef189 { color: #d7d7ff; } .eb189 { background-color: #d7d7ff; }
.ef190 { color: #d7ff00; } .eb190 { background-color: #d7ff00; }
.ef191 { color: #d7ff5f; } .eb191 { background-color: #d7ff5f; }
.ef192 { color: #d7ff87; } .eb192 { background-color: #d7ff87; }
.ef193 { color: #d7ffaf; } .eb193 { background-color: #d7ffaf; }
.ef194 { color: #d7ffd7; } .eb194 { background-color: #d7ffd7; }
.ef195 { color: #d7ffff; } .eb195 { background-color: #d7ffff; }
.ef196 { color: #ff0000; } .eb196 { background-color: #ff0000; }
.ef197 { color: #ff005f; } .eb197 { background-color: #ff005f; }
.ef198 { color: #ff0087; } .eb198 { background-color: #ff0087; }
.ef199 { color: #ff00af; } .eb199 { background-color: #ff00af; }
.ef200 { color: #ff00d7; } .eb200 { background-color: #ff00d7; }
.ef201 { color: #ff00ff; } .eb201 { background-color: #ff00ff; }
.ef202 { color: #ff5f00; } .eb202 { background-color: #ff5f00; }
.ef203 { color: #ff5f5f; } .eb203 { background-color: #ff5f5f; }
.ef204 { color: #ff5f87; } .eb204 { background-color: #ff5f87; }
.ef205 { color: #ff5faf; } .eb205 { background-color: #ff5faf; }
.ef206 { color: #ff5fd7; } .eb206 { background-color: #ff5fd7; }
.ef207 { color: #ff5fff; } .eb207 { background-color: #ff5fff; }
.ef208 { color: #ff8700; } .eb208 { background-color: #ff8700; }
.ef209 { color: #ff875f; } .eb209 { background-color: #ff875f; }
.ef210 { color: #ff8787; } .eb210 { background-color: #ff8787; }
.ef211 { color: #ff87af; } .eb211 { background-color: #ff87af; }
.ef212 { color: #ff87d7; } .eb212 { background-color: #ff87d7; }
.ef213 { color: #ff87ff; } .eb213 { background-color: #ff87ff; }
.ef214 { color: #ffaf00; } .eb214 { background-color: #ffaf00; }
.ef215 { color: #ffaf5f; } .eb215 { background-color: #ffaf5f; }
.ef216 { color: #ffaf87; } .eb216 { background-color: #ffaf87; }
.ef217 { color: #ffafaf; } .eb217 { background-color: #ffafaf; }
.ef218 { color: #ffafd7; } .eb218 { background-color: #ffafd7; }
.ef219 { color: #ffafff; } .eb219 { background-color: #ffafff; }
.ef220 { color: #ffd700; } .eb220 { background-color: #ffd700; }
.ef221 { color: #ffd75f; } .eb221 { background-color: #ffd75f; }
.ef222 { color: #ffd787; } .eb222 { background-color: #ffd787; }
.ef223 { color: #ffd7af; } .eb223 { background-color: #ffd7af; }
.ef224 { color: #ffd7d7; } .eb224 { background-color: #ffd7d7; }
.ef225 { color: #ffd7ff; } .eb225 { background-color: #ffd7ff; }
.ef226 { color: #ffff00; } .eb226 { background-color: #ffff00; }
.ef227 { color: #ffff5f; } .eb227 { background-color: #ffff5f; }
.ef228 { color: #ffff87; } .eb228 { background-color: #ffff87; }
.ef229 { color: #ffffaf; } .eb229 { background-color: #ffffaf; }
.ef230 { color: #ffffd7; } .eb230 { background-color: #ffffd7; }
.ef231 { color: #ffffff; } .eb231 { background-color: #ffffff; }
.ef232 { color: #080808; } .eb232 { background-color: #080808; }
.ef233 { color: #121212; } .eb233 { background-color: #121212; }
.ef234 { color: #1c1c1c; } .eb234 { background-color: #1c1c1c; }
.ef235 { color: #262626; } .eb235 { background-color: #262626; }
.ef236 { color: #303030; } .eb236 { background-color: #303030; }
.ef237 { color: #3a3a3a; } .eb237 { background-color: #3a3a3a; }
.ef238 { color: #444444; } .eb238 { background-color: #444444; }
.ef239 { color: #4e4e4e; } .eb239 { background-color: #4e4e4e; }
.ef240 { color: #585858; } .eb240 { background-color: #585858; }
.ef241 { color: #626262; } .eb241 { background-color: #626262; }
.ef242 { color: #6c6c6c; } .eb242 { background-color: #6c6c6c; }
.ef243 { color: #767676; } .eb243 { background-color: #767676; }
.ef244 { color: #808080; } .eb244 { background-color: #808080; }
.ef245 { color: #8a8a8a; } .eb245 { background-color: #8a8a8a; }
.ef246 { color: #949494; } .eb246 { background-color: #949494; }
.ef247 { color: #9e9e9e; } .eb247 { background-color: #9e9e9e; }
.ef248 { color: #a8a8a8; } .eb248 { background-color: #a8a8a8; }
.ef249 { color: #b2b2b2; } .eb249 { background-color: #b2b2b2; }
.ef250 { color: #bcbcbc; } .eb250 { background-color: #bcbcbc; }
.ef251 { color: #c6c6c6; } .eb251 { background-color: #c6c6c6; }
.ef252 { color: #d0d0d0; } .eb252 { background-color: #d0d0d0; }
.ef253 { color: #dadada; } .eb253 { background-color: #dadada; }
.ef254 { color: #e4e4e4; } .eb254 { background-color: #e4e4e4; }
.ef255 { color: #eeeeee; } .eb255 { background-color: #eeeeee; }

.f9 { color: #000000; }
.b9 { background-color: #FFFFFF; }
.f9 > .bold,.bold > .f9, body.f9 > pre > .bold {
  /* Bold is heavy black on white, or bright white
     depending on the default background */
  color: #000000;
  font-weight: bold;
}
.reverse {
  /* CSS does not support swapping fg and bg colours unfortunately,
     so just hardcode something that will look OK on all backgrounds. */
  color: #000000; background-color: #AAAAAA;
}
.underline { text-decoration: underline; }
.line-through { text-decoration: line-through; }
.blink { text-decoration: blink; }

/* Avoid pixels between adjacent span elements.
   Note this only works for lines less than 80 chars
   where we close span elements on the same line.
span { display: inline-block; }
*/
</style>
</head>

<body class="f9 b9">
<pre>
<span class="bold">diff --git a/wire/msgmixciphertexts.go b/wire/msgmixciphertexts.go</span>
<span class="bold">index 277dab4e..49bcfe00 100644</span>
<span class="bold">--- a/wire/msgmixciphertexts.go</span>
<span class="bold">+++ b/wire/msgmixciphertexts.go</span>
<span class="f6">@@ -9,7 +9,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 // MsgMixCiphertexts is used by mixing peers to share SNTRUP4591761
<span class="f6">@@ -31,12 +31,12 @@</span> type MsgMixCiphertexts struct {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixCiphertexts) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixCiphertexts) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {
</span> 	const op = &quot;MsgMixCiphertexts.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.SessionID,
<span class="f6">@@ -53,7 +53,7 @@</span> func (msg *MsgMixCiphertexts) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	ciphertexts := make([][1047]byte, count)
<span class="f6">@@ -79,12 +79,12 @@</span> func (msg *MsgMixCiphertexts) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixCiphertexts) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixCiphertexts) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {
</span> 	const op = &quot;MsgMixCiphertexts.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -140,12 +140,12 @@</span> func (msg *MsgMixCiphertexts) writeMessageNoSignature(op string, w io.Writer, pv
 		msg := fmt.Sprintf(&quot;differing counts of ciphertexts (%d) &quot;+
 			&quot;and seen key exchange messages (%d)&quot;, count,
 			len(msg.SeenKeyExchanges))
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if !hashing &amp;&amp; count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElements(w, &amp;msg.Identity, &amp;msg.SessionID, msg.Run)
<span class="bold">diff --git a/wire/msgmixciphertexts_test.go b/wire/msgmixciphertexts_test.go</span>
<span class="bold">index f3193c19..aa919a1d 100644</span>
<span class="bold">--- a/wire/msgmixciphertexts_test.go</span>
<span class="bold">+++ b/wire/msgmixciphertexts_test.go</span>
<span class="f6">@@ -6,13 +6,13 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
 )
 
 func newTestMixCiphertexts() *MsgMixCiphertexts {
<span class="f6">@@ -45,7 +45,7 @@</span> func TestMsgMixCiphertextsWire(t *testing.T) {
 	ct := newTestMixCiphertexts()
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err := ct.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err := ct.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -71,7 +71,7 @@</span> func TestMsgMixCiphertextsWire(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedCT := new(MsgMixCiphertexts)
<span class="f1">-	err = decodedCT.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedCT.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -89,7 +89,7 @@</span> func TestMsgMixCiphertextsCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -99,7 +99,7 @@</span> func TestMsgMixCiphertextsCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -111,7 +111,7 @@</span> func TestMsgMixCiphertextsCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -119,14 +119,14 @@</span> func TestMsgMixCiphertextsCrossProtocol(t *testing.T) {
 			msg := newTestMixCiphertexts()
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err := msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err := msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixCiphertexts)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
<span class="bold">diff --git a/wire/msgmixconfirm.go b/wire/msgmixconfirm.go</span>
<span class="bold">index f6054bb8..ab09f4be 100644</span>
<span class="bold">--- a/wire/msgmixconfirm.go</span>
<span class="bold">+++ b/wire/msgmixconfirm.go</span>
<span class="f6">@@ -9,7 +9,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 // MsgMixConfirm contains a partially-signed mix transaction, with signatures
<span class="f6">@@ -34,12 +34,12 @@</span> type MsgMixConfirm struct {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixConfirm) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixConfirm) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixConfirm.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.SessionID,
<span class="f6">@@ -48,7 +48,7 @@</span> func (msg *MsgMixConfirm) BtcDecode(r io.Reader, pver uint32) error {
 		return err
 	}
 
<span class="f1">-	err = msg.Mix.BtcDecode(r, pver)</span>
<span class="f2">+</span>	<span class="f2">err = msg.Mix.BtcDecode(r, pver, BaseEncoding)</span>
 	if err != nil {
 		return err
 	}
<span class="f6">@@ -60,7 +60,7 @@</span> func (msg *MsgMixConfirm) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	seen := make([]chainhash.Hash, count)
<span class="f6">@@ -77,12 +77,12 @@</span> func (msg *MsgMixConfirm) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixConfirm) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixConfirm) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixConfirm.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -137,7 +137,7 @@</span> func (msg *MsgMixConfirm) writeMessageNoSignature(op string, w io.Writer, pver u
 	if !hashing &amp;&amp; count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElements(w, &amp;msg.Identity, &amp;msg.SessionID, msg.Run)
<span class="f6">@@ -145,7 +145,7 @@</span> func (msg *MsgMixConfirm) writeMessageNoSignature(op string, w io.Writer, pver u
 		return err
 	}
 
<span class="f1">-	err = msg.Mix.BtcEncode(w, pver)</span>
<span class="f2">+</span>	<span class="f2">err = msg.Mix.BtcEncode(w, pver, BaseEncoding)</span>
 	if err != nil {
 		return err
 	}
<span class="f6">@@ -221,7 +221,7 @@</span> func NewMsgMixConfirm(identity [33]byte, sid [32]byte, run uint32,
 	mix *MsgTx, seenDCNets []chainhash.Hash) *MsgMixConfirm {
 
 	if mix == nil {
<span class="f1">-		mix = NewMsgTx()</span>
<span class="f2">+</span>		<span class="f2">mix = NewMsgTx(TxVersion)</span>
 	}
 
 	return &amp;MsgMixConfirm{
<span class="bold">diff --git a/wire/msgmixconfirm_test.go b/wire/msgmixconfirm_test.go</span>
<span class="bold">index 09be5b4b..47f5e986 100644</span>
<span class="bold">--- a/wire/msgmixconfirm_test.go</span>
<span class="bold">+++ b/wire/msgmixconfirm_test.go</span>
<span class="f6">@@ -6,13 +6,13 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
 )
 
 func newTestMixConfirm() *MsgMixConfirm {
<span class="f6">@@ -23,7 +23,7 @@</span> func newTestMixConfirm() *MsgMixConfirm {
 
 	const run = uint32(0x83838383)
 
<span class="f1">-	mix := NewMsgTx()</span>
<span class="f2">+</span>	<span class="f2">mix := NewMsgTx(TxVersion)</span>
 
 	seenDCs := make([]chainhash.Hash, 4)
 	for b := byte(0x84); b &lt; 0x88; b++ {
<span class="f6">@@ -42,7 +42,7 @@</span> func TestMsgMixConfirmWire(t *testing.T) {
 	cm := newTestMixConfirm()
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err := cm.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err := cm.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -57,8 +57,8 @@</span> func TestMsgMixConfirmWire(t *testing.T) {
 		0x00,                   // Varint for number of input transactions
 		0x00,                   // Varint for number of output transactions
 		0x00, 0x00, 0x00, 0x00, // Lock time
<span class="f1">-		0x00, 0x00, 0x00, 0x00, // Expiry</span>
<span class="f1">-		0x00, // Varint for number of input signatures</span>
<span class="f2">+</span>		<span class="f2">// 0x00, 0x00, 0x00, 0x00, // Expiry (btc does not encode expiry)</span>
<span class="f2">+</span>		<span class="f2">// 0x00, // Varint for number of input signatures (btc does not encode number of input signatures)</span>
 	}...)
 	// Four seen DCs (repeating 32 bytes of 0x84, 0x85, 0x86, 0x87)
 	expected = append(expected, 0x04)
<span class="f6">@@ -70,7 +70,7 @@</span> func TestMsgMixConfirmWire(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedCM := new(MsgMixConfirm)
<span class="f1">-	err = decodedCM.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedCM.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -88,7 +88,7 @@</span> func TestMsgMixConfirmCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -98,7 +98,7 @@</span> func TestMsgMixConfirmCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -110,7 +110,7 @@</span> func TestMsgMixConfirmCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -118,14 +118,14 @@</span> func TestMsgMixConfirmCrossProtocol(t *testing.T) {
 			msg := newTestMixConfirm()
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err := msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err := msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixConfirm)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
<span class="bold">diff --git a/wire/msgmixdcnet.go b/wire/msgmixdcnet.go</span>
<span class="bold">index c6fc4db9..f9ccab74 100644</span>
<span class="bold">--- a/wire/msgmixdcnet.go</span>
<span class="bold">+++ b/wire/msgmixdcnet.go</span>
<span class="f6">@@ -9,7 +9,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 // MsgMixDCNet is the DC-net broadcast.  It implements the Message interface.
<span class="f6">@@ -29,12 +29,12 @@</span> type MsgMixDCNet struct {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixDCNet) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixDCNet) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixDCNet.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.SessionID,
<span class="f6">@@ -57,7 +57,7 @@</span> func (msg *MsgMixDCNet) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	seen := make([]chainhash.Hash, count)
<span class="f6">@@ -74,12 +74,12 @@</span> func (msg *MsgMixDCNet) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixDCNet) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixDCNet) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixDCNet.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -133,17 +133,17 @@</span> func (msg *MsgMixDCNet) writeMessageNoSignature(op string, w io.Writer, pver uin
 	mcount := len(msg.DCNet)
 	if !hashing &amp;&amp; mcount == 0 {
 		msg := fmt.Sprintf(&quot;too few mixed messages [%v]&quot;, mcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if !hashing &amp;&amp; mcount &gt; MaxMixMcount {
 		msg := fmt.Sprintf(&quot;too many total mixed messages [%v]&quot;, mcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	srcount := len(msg.SeenSlotReserves)
 	if !hashing &amp;&amp; srcount &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			srcount, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElements(w, &amp;msg.Identity, &amp;msg.SessionID, msg.Run)
<span class="f6">@@ -221,12 +221,12 @@</span> func readMixVects(op string, r io.Reader, pver uint32, vecs *[]MixVect) error {
 
 	if x &gt; MaxMixMcount || y &gt; MaxMixMcount {
 		msg := &quot;DC-net mix vector dimensions are too large for maximum message count&quot;
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if msize != MixMsgSize {
 		msg := fmt.Sprintf(&quot;mixed message length must be %d [got: %d]&quot;,
 			MixMsgSize, msize)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	// Read messages
<span class="bold">diff --git a/wire/msgmixdcnet_test.go b/wire/msgmixdcnet_test.go</span>
<span class="bold">index 5885ffa1..21e42c09 100644</span>
<span class="bold">--- a/wire/msgmixdcnet_test.go</span>
<span class="bold">+++ b/wire/msgmixdcnet_test.go</span>
<span class="f6">@@ -6,13 +6,13 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
 )
 
 func newTestMixDCNet() *MsgMixDCNet {
<span class="f6">@@ -54,7 +54,7 @@</span> func TestMsgMixDCNetWire(t *testing.T) {
 	dc := newTestMixDCNet()
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err := dc.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err := dc.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -95,7 +95,7 @@</span> func TestMsgMixDCNetWire(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedDC := new(MsgMixDCNet)
<span class="f1">-	err = decodedDC.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedDC.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -113,7 +113,7 @@</span> func TestMsgMixDCNetCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -123,7 +123,7 @@</span> func TestMsgMixDCNetCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -135,7 +135,7 @@</span> func TestMsgMixDCNetCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -143,14 +143,14 @@</span> func TestMsgMixDCNetCrossProtocol(t *testing.T) {
 			msg := newTestMixDCNet()
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err := msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err := msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixDCNet)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
<span class="bold">diff --git a/wire/msgmixfactoredpoly.go b/wire/msgmixfactoredpoly.go</span>
<span class="bold">index 2547ba50..727f5884 100644</span>
<span class="bold">--- a/wire/msgmixfactoredpoly.go</span>
<span class="bold">+++ b/wire/msgmixfactoredpoly.go</span>
<span class="f6">@@ -9,7 +9,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 // MsgMixFactoredPoly encodes the solution of the factored slot reservation
<span class="f6">@@ -30,12 +30,12 @@</span> type MsgMixFactoredPoly struct {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixFactoredPoly) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixFactoredPoly) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixFactoredPoly.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.SessionID,
<span class="f6">@@ -51,7 +51,7 @@</span> func (msg *MsgMixFactoredPoly) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixMcount {
 		msg := fmt.Sprintf(&quot;too many roots in message [count %v, max %v]&quot;,
 			count, MaxMixMcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	roots := make([][]byte, count)
<span class="f6">@@ -71,7 +71,7 @@</span> func (msg *MsgMixFactoredPoly) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	seen := make([]chainhash.Hash, count)
<span class="f6">@@ -88,12 +88,12 @@</span> func (msg *MsgMixFactoredPoly) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixFactoredPoly) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixFactoredPoly) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixFactoredPoly.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -148,19 +148,19 @@</span> func (msg *MsgMixFactoredPoly) writeMessageNoSignature(op string, w io.Writer, p
 	if !hashing &amp;&amp; count &gt; MaxMixMcount {
 		msg := fmt.Sprintf(&quot;too many solutions to factored polynomial [count %v, max %v]&quot;,
 			count, MaxMixMcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	for _, root := range msg.Roots {
 		if !hashing &amp;&amp; len(root) &gt; MaxMixFieldValLen {
 			msg := &quot;root exceeds bytes necessary to represent number in field&quot;
<span class="f1">-			return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>			<span class="f2">return messageError(op, msg)</span>
 		}
 	}
 	srcount := len(msg.SeenSlotReserves)
 	if !hashing &amp;&amp; srcount &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			srcount, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElements(w, &amp;msg.Identity, &amp;msg.SessionID, msg.Run)
<span class="bold">diff --git a/wire/msgmixfactoredpoly_test.go b/wire/msgmixfactoredpoly_test.go</span>
<span class="bold">index 56c201fe..33141e15 100644</span>
<span class="bold">--- a/wire/msgmixfactoredpoly_test.go</span>
<span class="bold">+++ b/wire/msgmixfactoredpoly_test.go</span>
<span class="f6">@@ -6,13 +6,13 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
 )
 
 func newTestMixFactoredPoly() *MsgMixFactoredPoly {
<span class="f6">@@ -49,7 +49,7 @@</span> func TestMsgMixFactoredPoly(t *testing.T) {
 	fp := newTestMixFactoredPoly()
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err := fp.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err := fp.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -79,7 +79,7 @@</span> func TestMsgMixFactoredPoly(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedFP := new(MsgMixFactoredPoly)
<span class="f1">-	err = decodedFP.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedFP.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -97,7 +97,7 @@</span> func TestMsgMixFactoredPolyCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -107,7 +107,7 @@</span> func TestMsgMixFactoredPolyCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -119,7 +119,7 @@</span> func TestMsgMixFactoredPolyCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -127,14 +127,14 @@</span> func TestMsgMixFactoredPolyCrossProtocol(t *testing.T) {
 			msg := newTestMixFactoredPoly()
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err := msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err := msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixFactoredPoly)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
<span class="bold">diff --git a/wire/msgmixkeyexchange.go b/wire/msgmixkeyexchange.go</span>
<span class="bold">index 938612eb..a1e2a381 100644</span>
<span class="bold">--- a/wire/msgmixkeyexchange.go</span>
<span class="bold">+++ b/wire/msgmixkeyexchange.go</span>
<span class="f6">@@ -9,7 +9,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 const (
<span class="f6">@@ -46,12 +46,12 @@</span> type MsgMixKeyExchange struct {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixKeyExchange) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixKeyExchange) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixKeyExchange.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.SessionID,
<span class="f6">@@ -67,7 +67,7 @@</span> func (msg *MsgMixKeyExchange) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	seen := make([]chainhash.Hash, count)
<span class="f6">@@ -84,12 +84,12 @@</span> func (msg *MsgMixKeyExchange) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixKeyExchange) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixKeyExchange) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixKeyExchange.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -145,7 +145,7 @@</span> func (msg *MsgMixKeyExchange) writeMessageNoSignature(op string, w io.Writer, pv
 	if !hashing &amp;&amp; count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElements(w, &amp;msg.Identity, &amp;msg.SessionID, msg.Epoch,
<span class="bold">diff --git a/wire/msgmixkeyexchange_test.go b/wire/msgmixkeyexchange_test.go</span>
<span class="bold">index 4e62ea6d..9bfe3397 100644</span>
<span class="bold">--- a/wire/msgmixkeyexchange_test.go</span>
<span class="bold">+++ b/wire/msgmixkeyexchange_test.go</span>
<span class="f6">@@ -6,13 +6,13 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
 )
 
 func newTestMixKeyExchange() *MsgMixKeyExchange {
<span class="f6">@@ -46,7 +46,7 @@</span> func TestMsgMixKeyExchangeWire(t *testing.T) {
 	ke := newTestMixKeyExchange()
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err := ke.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err := ke.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -71,7 +71,7 @@</span> func TestMsgMixKeyExchangeWire(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedKE := new(MsgMixKeyExchange)
<span class="f1">-	err = decodedKE.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedKE.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -92,7 +92,7 @@</span> func TestMsgMixKeyExchangeCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -102,7 +102,7 @@</span> func TestMsgMixKeyExchangeCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -114,7 +114,7 @@</span> func TestMsgMixKeyExchangeCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -122,14 +122,14 @@</span> func TestMsgMixKeyExchangeCrossProtocol(t *testing.T) {
 			msg := newTestMixKeyExchange()
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err := msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err := msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixKeyExchange)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
<span class="bold">diff --git a/wire/msgmixpairreq.go b/wire/msgmixpairreq.go</span>
<span class="bold">index 6abd07b0..514ddf9f 100644</span>
<span class="bold">--- a/wire/msgmixpairreq.go</span>
<span class="bold">+++ b/wire/msgmixpairreq.go</span>
<span class="f6">@@ -10,7 +10,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 const (
<span class="f6">@@ -62,7 +62,7 @@</span> type MsgMixPairReq struct {
 	Expiry       uint32
 	MixAmount    int64
 	ScriptClass  string
<span class="f1">-	TxVersion    uint16</span>
<span class="f2">+</span>	<span class="f2">TxVersion    int32</span>
 	LockTime     uint32
 	MessageCount uint32
 	InputValue   int64
<span class="f6">@@ -109,12 +109,12 @@</span> func (msg *MsgMixPairReq) Pairing() ([]byte, error) {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixPairReq) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixPairReq) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixPairReq.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.Expiry,
<span class="f6">@@ -125,7 +125,7 @@</span> func (msg *MsgMixPairReq) BtcDecode(r io.Reader, pver uint32) error {
 
 	if msg.MixAmount &lt; 0 {
 		msg := &quot;mixing pair request contains negative mixed amount&quot;
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	sc, err := ReadAsciiVarString(r, pver, MaxMixPairReqScriptClassLen)
<span class="f6">@@ -142,7 +142,7 @@</span> func (msg *MsgMixPairReq) BtcDecode(r io.Reader, pver uint32) error {
 
 	if msg.InputValue &lt; 0 {
 		msg := &quot;mixing pair request contains negative input value&quot;
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	count, err := ReadVarInt(r, pver)
<span class="f6">@@ -152,7 +152,7 @@</span> func (msg *MsgMixPairReq) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPairReqUTXOs {
 		msg := fmt.Sprintf(&quot;too many UTXOs in message [count %v, max %v]&quot;,
 			count, MaxMixPairReqUTXOs)
<span class="f1">-		return messageError(op, ErrTooManyMixPairReqUTXOs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	utxos := make([]MixPairReqUTXO, count)
 	for i := range utxos {
<span class="f6">@@ -202,14 +202,14 @@</span> func (msg *MsgMixPairReq) BtcDecode(r io.Reader, pver uint32) error {
 	case 0:
 	case 1:
 		change := new(TxOut)
<span class="f1">-		err := readTxOut(r, pver, msg.TxVersion, change)</span>
<span class="f2">+</span>		<span class="f2">err := ReadTxOut(r, pver, msg.TxVersion, change)</span>
 		if err != nil {
 			return err
 		}
 		msg.Change = change
 	default:
 		msg := &quot;invalid change TxOut encoding&quot;
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	return readElements(r, &amp;msg.Flags, &amp;msg.PairingFlags)
<span class="f6">@@ -217,12 +217,12 @@</span> func (msg *MsgMixPairReq) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixPairReq) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixPairReq) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixPairReq.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -280,18 +280,18 @@</span> func (msg *MsgMixPairReq) writeMessageNoSignature(op string, w io.Writer, pver u
 		msg := fmt.Sprintf(&quot;script class length is too long &quot;+
 			&quot;[len %d, max %d]&quot;, lenScriptClass,
 			MaxMixPairReqScriptClassLen)
<span class="f1">-		return messageError(op, ErrMixPairReqScriptClassTooLong, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if !isStrictAscii(msg.ScriptClass) {
 		msg := &quot;script class string is not strict ASCII&quot;
<span class="f1">-		return messageError(op, ErrMalformedStrictString, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	// Limit to max UTXOs per message.
 	count := len(msg.UTXOs)
 	if !hashing &amp;&amp; count &gt; MaxMixPairReqUTXOs {
 		msg := fmt.Sprintf(&quot;too many UTXOs in message [%v]&quot;, count)
<span class="f1">-		return messageError(op, ErrTooManyMixPairReqUTXOs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElements(w, &amp;msg.Identity, msg.Expiry, msg.MixAmount)
<span class="f6">@@ -325,7 +325,7 @@</span> func (msg *MsgMixPairReq) writeMessageNoSignature(op string, w io.Writer, pver u
 		if l := len(utxo.Script); !hashing &amp;&amp; l &gt; MaxMixPairReqUTXOScriptLen {
 			msg := fmt.Sprintf(&quot;UTXO script is too long [len %v, max %v]&quot;,
 				l, MaxMixPairReqUTXOScriptLen)
<span class="f1">-			return messageError(op, ErrVarBytesTooLong, msg)</span>
<span class="f2">+</span>			<span class="f2">return messageError(op, msg)</span>
 		}
 		err = WriteVarBytes(w, pver, utxo.Script)
 		if err != nil {
<span class="f6">@@ -335,7 +335,7 @@</span> func (msg *MsgMixPairReq) writeMessageNoSignature(op string, w io.Writer, pver u
 		if l := len(utxo.PubKey); !hashing &amp;&amp; l &gt; MaxMixPairReqUTXOPubKeyLen {
 			msg := fmt.Sprintf(&quot;UTXO public key is too long [len %v, max %v]&quot;,
 				l, MaxMixPairReqUTXOPubKeyLen)
<span class="f1">-			return messageError(op, ErrVarBytesTooLong, msg)</span>
<span class="f2">+</span>			<span class="f2">return messageError(op, msg)</span>
 		}
 		err = WriteVarBytes(w, pver, utxo.PubKey)
 		if err != nil {
<span class="f6">@@ -345,7 +345,7 @@</span> func (msg *MsgMixPairReq) writeMessageNoSignature(op string, w io.Writer, pver u
 		if l := len(utxo.Signature); !hashing &amp;&amp; l &gt; MaxMixPairReqUTXOSignatureLen {
 			msg := fmt.Sprintf(&quot;UTXO signature is too long [len %v, max %v]&quot;,
 				l, MaxMixPairReqUTXOSignatureLen)
<span class="f1">-			return messageError(op, ErrVarBytesTooLong, msg)</span>
<span class="f2">+</span>			<span class="f2">return messageError(op, msg)</span>
 		}
 		err = WriteVarBytes(w, pver, utxo.Signature)
 		if err != nil {
<span class="f6">@@ -367,7 +367,7 @@</span> func (msg *MsgMixPairReq) writeMessageNoSignature(op string, w io.Writer, pver u
 		return err
 	}
 	if msg.Change != nil {
<span class="f1">-		err = writeTxOut(w, pver, msg.TxVersion, msg.Change)</span>
<span class="f2">+</span>		<span class="f2">err = WriteTxOut(w, pver, msg.TxVersion, msg.Change)</span>
 		if err != nil {
 			return err
 		}
<span class="f6">@@ -440,7 +440,7 @@</span> func (msg *MsgMixPairReq) GetRun() uint32 {
 // Message interface using the passed parameters and defaults for the
 // remaining fields.
 func NewMsgMixPairReq(identity [33]byte, expiry uint32, mixAmount int64,
<span class="f1">-	scriptClass string, txVersion uint16, lockTime, messageCount uint32,</span>
<span class="f2">+</span>	<span class="f2">scriptClass string, txVersion int32, lockTime, messageCount uint32,</span>
 	inputValue int64, utxos []MixPairReqUTXO, change *TxOut,
 	flags, pairingFlags byte) (*MsgMixPairReq, error) {
 
<span class="f6">@@ -450,18 +450,18 @@</span> func NewMsgMixPairReq(identity [33]byte, expiry uint32, mixAmount int64,
 		msg := fmt.Sprintf(&quot;script class length is too long &quot;+
 			&quot;[len %d, max %d]&quot;, lenScriptClass,
 			MaxMixPairReqScriptClassLen)
<span class="f1">-		return nil, messageError(op, ErrMixPairReqScriptClassTooLong, msg)</span>
<span class="f2">+</span>		<span class="f2">return nil, messageError(op, msg)</span>
 	}
 
 	if !isStrictAscii(scriptClass) {
 		msg := &quot;script class string is not strict ASCII&quot;
<span class="f1">-		return nil, messageError(op, ErrMalformedStrictString, msg)</span>
<span class="f2">+</span>		<span class="f2">return nil, messageError(op, msg)</span>
 	}
 
 	if len(utxos) &gt; MaxMixPairReqUTXOs {
 		msg := fmt.Sprintf(&quot;too many input UTXOs [len %d, max %d]&quot;,
 			len(utxos), MaxMixPairReqUTXOs)
<span class="f1">-		return nil, messageError(op, ErrTooManyMixPairReqUTXOs, msg)</span>
<span class="f2">+</span>		<span class="f2">return nil, messageError(op, msg)</span>
 	}
 
 	msg := &amp;MsgMixPairReq{
<span class="bold">diff --git a/wire/msgmixpairreq_test.go b/wire/msgmixpairreq_test.go</span>
<span class="bold">index 8c541fdf..7364d083 100644</span>
<span class="bold">--- a/wire/msgmixpairreq_test.go</span>
<span class="bold">+++ b/wire/msgmixpairreq_test.go</span>
<span class="f6">@@ -6,9 +6,9 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f6">@@ -20,7 +20,7 @@</span> type mixPairReqArgs struct {
 	expiry                 uint32
 	mixAmount              int64
 	scriptClass            string
<span class="f1">-	txVersion              uint16</span>
<span class="f2">+</span>	<span class="f2">txVersion              int32</span>
 	lockTime, messageCount uint32
 	inputValue             int64
 	utxos                  []MixPairReqUTXO
<span class="f6">@@ -44,7 +44,7 @@</span> func newMixPairReqArgs() *mixPairReqArgs {
 	const expiry = uint32(0x82828282)
 	const mixAmount = int64(0x0383838383838383)
 	const sc = &quot;P2PKH-secp256k1-v0&quot;
<span class="f1">-	const txVersion = uint16(0x8484)</span>
<span class="f2">+</span>	<span class="f2">const txVersion = int32(0x8484)</span>
 	const lockTime = uint32(0x85858585)
 	const messageCount = uint32(0x86868686)
 	const inputValue = int64(0x0787878787878787)
<span class="f6">@@ -54,7 +54,7 @@</span> func newMixPairReqArgs() *mixPairReqArgs {
 			OutPoint: OutPoint{
 				Hash:  rhash(0x88),
 				Index: 0x89898989,
<span class="f1">-				Tree:  0x0A,</span>
<span class="f2">+</span>				<span class="f2">// Tree:  0x0A,</span>
 			},
 			Script:    []byte{},
 			PubKey:    repeat(0x8B, 33),
<span class="f6">@@ -65,7 +65,7 @@</span> func newMixPairReqArgs() *mixPairReqArgs {
 			OutPoint: OutPoint{
 				Hash:  rhash(0x8D),
 				Index: 0x8E8E8E8E,
<span class="f1">-				Tree:  0x0F,</span>
<span class="f2">+</span>				<span class="f2">// Tree:  0x0F,</span>
 			},
 			Script:    repeat(0x90, 25),
 			PubKey:    repeat(0x91, 33),
<span class="f6">@@ -110,7 +110,7 @@</span> func TestMsgMixPairReqWire(t *testing.T) {
 	pr.Signature = a.signature
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err = pr.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err = pr.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -123,7 +123,7 @@</span> func TestMsgMixPairReqWire(t *testing.T) {
 		0x83, 0x83, 0x83, 0x03)
 	expected = append(expected, byte(len(&quot;P2PKH-secp256k1-v0&quot;))) // Script class
 	expected = append(expected, []byte(&quot;P2PKH-secp256k1-v0&quot;)...)
<span class="f1">-	expected = append(expected, 0x84, 0x84)             // Tx version</span>
<span class="f2">+</span>	<span class="f2">expected = append(expected, 0x84, 0x84, 0x0, 0x0)   // Tx version (int32 instead of uint16)</span>
 	expected = append(expected, repeat(0x85, 4)...)     // Locktime
 	expected = append(expected, repeat(0x86, 4)...)     // Message count
 	expected = append(expected, 0x87, 0x87, 0x87, 0x87, // Input value
<span class="f6">@@ -132,9 +132,9 @@</span> func TestMsgMixPairReqWire(t *testing.T) {
 	// First UTXO 8888888888888888888888888888888888888888888888888888888888888888:0x89898989
 	expected = append(expected, repeat(0x88, 32)...) // Hash
 	expected = append(expected, repeat(0x89, 4)...)  // Index
<span class="f1">-	expected = append(expected, 0x0a)                // Tree</span>
<span class="f1">-	expected = append(expected, 0x00)                // Zero-length P2SH redeem script</span>
<span class="f1">-	expected = append(expected, 0x21)                // 33-byte pubkey</span>
<span class="f2">+</span>	<span class="f2">// expected = append(expected, 0x0a)                // Tree (btc does not encode tree)</span>
<span class="f2">+</span>	<span class="f2">expected = append(expected, 0x00) // Zero-length P2SH redeem script</span>
<span class="f2">+</span>	<span class="f2">expected = append(expected, 0x21) // 33-byte pubkey</span>
 	expected = append(expected, repeat(0x8b, 33)...)
 	expected = append(expected, 0x40) // 64-byte signature
 	expected = append(expected, repeat(0x8c, 64)...)
<span class="f6">@@ -142,8 +142,8 @@</span> func TestMsgMixPairReqWire(t *testing.T) {
 	// Second UTXO 8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d8d:0x8e8e8e8e
 	expected = append(expected, repeat(0x8d, 32)...) // Hash
 	expected = append(expected, repeat(0x8e, 4)...)  // Index
<span class="f1">-	expected = append(expected, 0x0f)                // Tree</span>
<span class="f1">-	expected = append(expected, 0x19)                // 25-byte P2SH redeem script</span>
<span class="f2">+</span>	<span class="f2">// expected = append(expected, 0x0f)                // Tree (btc does not encode tree)</span>
<span class="f2">+</span>	<span class="f2">expected = append(expected, 0x19) // 25-byte P2SH redeem script</span>
 	expected = append(expected, repeat(0x90, 25)...)
 	expected = append(expected, 0x21) // 33-byte pubkey
 	expected = append(expected, repeat(0x91, 33)...)
<span class="f6">@@ -154,7 +154,7 @@</span> func TestMsgMixPairReqWire(t *testing.T) {
 	expected = append(expected, 0x01) // Has change = true
 	expected = append(expected, []byte{
 		0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x13, // Amount
<span class="f1">-		0x00, 0x00, // Version</span>
<span class="f2">+</span>		<span class="f2">// 0x00, 0x00, // Version (btc does not encode output version)</span>
 		0x19, // 25-byte Pkscript
 		0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
 		0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
<span class="f6">@@ -167,7 +167,7 @@</span> func TestMsgMixPairReqWire(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedPR := new(MsgMixPairReq)
<span class="f1">-	err = decodedPR.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedPR.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -184,25 +184,25 @@</span> func TestNewMixPairReqErrs(t *testing.T) {
 	tests := []struct {
 		name    string
 		modArgs func(*mixPairReqArgs)
<span class="f1">-		err     error</span>
<span class="f2">+</span>		<span class="f2">err     string</span>
 	}{{
 		name: &quot;LongScriptClass&quot;,
 		modArgs: func(a *mixPairReqArgs) {
 			a.scriptClass = &quot;scriptclassthatexceedsmaximumlength&quot;
 		},
<span class="f1">-		err: ErrMixPairReqScriptClassTooLong,</span>
<span class="f2">+</span>		<span class="f2">err: &quot;script class length is too long&quot;,</span>
 	}, {
 		name: &quot;NonAsciiScriptClass&quot;,
 		modArgs: func(a *mixPairReqArgs) {
 			a.scriptClass = string([]byte{128})
 		},
<span class="f1">-		err: ErrMalformedStrictString,</span>
<span class="f2">+</span>		<span class="f2">err: &quot;script class string is not strict ASCII&quot;,</span>
 	}, {
 		name: &quot;TooManyUTXOs&quot;,
 		modArgs: func(a *mixPairReqArgs) {
 			a.utxos = make([]MixPairReqUTXO, MaxMixPairReqUTXOs+1)
 		},
<span class="f1">-		err: ErrTooManyMixPairReqUTXOs,</span>
<span class="f2">+</span>		<span class="f2">err: &quot;too many input UTXOs&quot;,</span>
 	}}
 	for _, tc := range tests {
 		tc := tc
<span class="f6">@@ -211,7 +211,7 @@</span> func TestNewMixPairReqErrs(t *testing.T) {
 			a := newMixPairReqArgs()
 			tc.modArgs(a)
 			_, err := a.msg()
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;expected error %v; got %v&quot;, tc.err, err)
 			}
 		})
<span class="f6">@@ -225,7 +225,7 @@</span> func TestMsgMixPairReqCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -235,7 +235,7 @@</span> func TestMsgMixPairReqCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -247,7 +247,7 @@</span> func TestMsgMixPairReqCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -259,14 +259,14 @@</span> func TestMsgMixPairReqCrossProtocol(t *testing.T) {
 			}
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err = msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixPairReq)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
<span class="bold">diff --git a/wire/msgmixsecrets.go b/wire/msgmixsecrets.go</span>
<span class="bold">index 8a194191..333ef912 100644</span>
<span class="bold">--- a/wire/msgmixsecrets.go</span>
<span class="bold">+++ b/wire/msgmixsecrets.go</span>
<span class="f6">@@ -9,7 +9,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 // MsgMixSecrets reveals secrets of a failed mix run.  After secrets are
<span class="f6">@@ -36,7 +36,7 @@</span> type MsgMixSecrets struct {
 func writeMixVect(op string, w io.Writer, pver uint32, vec MixVect) error {
 	if len(vec) &gt; MaxMixMcount {
 		msg := &quot;DC-net mix vector dimensions are too large for maximum message count&quot;
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	// Write dimensions
<span class="f6">@@ -80,12 +80,12 @@</span> func readMixVect(op string, r io.Reader, pver uint32, vec *MixVect) error {
 
 	if n &gt; MaxMixMcount {
 		msg := &quot;DC-net mix vector dimensions are too large for maximum message count&quot;
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if msize != MixMsgSize {
 		msg := fmt.Sprintf(&quot;mixed message length must be %d [got: %d]&quot;,
 			MixMsgSize, msize)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	// Read messages
<span class="f6">@@ -102,12 +102,12 @@</span> func readMixVect(op string, r io.Reader, pver uint32, vec *MixVect) error {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixSecrets) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixSecrets) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixSecrets.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.SessionID,
<span class="f6">@@ -123,7 +123,7 @@</span> func (msg *MsgMixSecrets) BtcDecode(r io.Reader, pver uint32) error {
 	if numSRs &gt; MaxMixMcount {
 		msg := fmt.Sprintf(&quot;too many total mixed messages [count %v, max %v]&quot;,
 			numSRs, MaxMixMcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	msg.SlotReserveMsgs = make([][]byte, numSRs)
 	for i := uint64(0); i &lt; numSRs; i++ {
<span class="f6">@@ -149,7 +149,7 @@</span> func (msg *MsgMixSecrets) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	seen := make([]chainhash.Hash, count)
<span class="f6">@@ -166,12 +166,12 @@</span> func (msg *MsgMixSecrets) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixSecrets) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixSecrets) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixSecrets.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -236,7 +236,7 @@</span> func (msg *MsgMixSecrets) writeMessageNoSignature(op string, w io.Writer, pver u
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElements(w, &amp;msg.Identity, &amp;msg.SessionID, msg.Run, &amp;msg.Seed)
<span class="bold">diff --git a/wire/msgmixsecrets_test.go b/wire/msgmixsecrets_test.go</span>
<span class="bold">index e0fc7935..08327c1f 100644</span>
<span class="bold">--- a/wire/msgmixsecrets_test.go</span>
<span class="bold">+++ b/wire/msgmixsecrets_test.go</span>
<span class="f6">@@ -6,13 +6,13 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
 )
 
 func newTestMixSecrets() *MsgMixSecrets {
<span class="f6">@@ -53,7 +53,7 @@</span> func TestMsgMixSecretsWire(t *testing.T) {
 	rs := newTestMixSecrets()
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err := rs.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err := rs.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -90,7 +90,7 @@</span> func TestMsgMixSecretsWire(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedRS := new(MsgMixSecrets)
<span class="f1">-	err = decodedRS.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedRS.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -108,7 +108,7 @@</span> func TestMsgMixSecretsCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -118,7 +118,7 @@</span> func TestMsgMixSecretsCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -130,7 +130,7 @@</span> func TestMsgMixSecretsCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -138,14 +138,14 @@</span> func TestMsgMixSecretsCrossProtocol(t *testing.T) {
 			msg := newTestMixSecrets()
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err := msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err := msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixSecrets)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
<span class="bold">diff --git a/wire/msgmixslotreserve.go b/wire/msgmixslotreserve.go</span>
<span class="bold">index 3c69fbf5..2151f174 100644</span>
<span class="bold">--- a/wire/msgmixslotreserve.go</span>
<span class="bold">+++ b/wire/msgmixslotreserve.go</span>
<span class="f6">@@ -9,7 +9,7 @@</span> import (
 	&quot;hash&quot;
 	&quot;io&quot;
 
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 )
 
 const (
<span class="f6">@@ -43,12 +43,12 @@</span> type MsgMixSlotReserve struct {
 
 // BtcDecode decodes r using the Decred protocol encoding into the receiver.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixSlotReserve) BtcDecode(r io.Reader, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixSlotReserve) BtcDecode(r io.Reader, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixSlotReserve.BtcDecode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := readElements(r, &amp;msg.Signature, &amp;msg.Identity, &amp;msg.SessionID,
<span class="f6">@@ -64,11 +64,11 @@</span> func (msg *MsgMixSlotReserve) BtcDecode(r io.Reader, pver uint32) error {
 	}
 	if mcount == 0 {
 		msg := fmt.Sprintf(&quot;too few mixed messages [%v]&quot;, mcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if mcount &gt; MaxMixMcount {
 		msg := fmt.Sprintf(&quot;too many total mixed messages [%v]&quot;, mcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	kpcount, err := ReadVarInt(r, pver)
 	if err != nil {
<span class="f6">@@ -76,12 +76,12 @@</span> func (msg *MsgMixSlotReserve) BtcDecode(r io.Reader, pver uint32) error {
 	}
 	if kpcount == 0 {
 		msg := fmt.Sprintf(&quot;too few mixing peers [%v]&quot;, kpcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if kpcount &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many mixing peers [count %v, max %v]&quot;,
 			kpcount, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	dcmix := make([][][]byte, mcount)
 	for i := range dcmix {
<span class="f6">@@ -104,7 +104,7 @@</span> func (msg *MsgMixSlotReserve) BtcDecode(r io.Reader, pver uint32) error {
 	if count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	seen := make([]chainhash.Hash, count)
<span class="f6">@@ -121,12 +121,12 @@</span> func (msg *MsgMixSlotReserve) BtcDecode(r io.Reader, pver uint32) error {
 
 // BtcEncode encodes the receiver to w using the Decred protocol encoding.
 // This is part of the Message interface implementation.
<span class="f1">-func (msg *MsgMixSlotReserve) BtcEncode(w io.Writer, pver uint32) error {</span>
<span class="f2">+func (msg *MsgMixSlotReserve) BtcEncode(w io.Writer, pver uint32, _ MessageEncoding) error {</span>
 	const op = &quot;MsgMixSlotReserve.BtcEncode&quot;
 	if pver &lt; MixVersion {
 		msg := fmt.Sprintf(&quot;%s message invalid for protocol version %d&quot;,
 			msg.Command(), pver)
<span class="f1">-		return messageError(op, ErrMsgInvalidForPVer, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err := writeElement(w, &amp;msg.Signature)
<span class="f6">@@ -186,20 +186,20 @@</span> func (msg *MsgMixSlotReserve) writeMessageNoSignature(op string, w io.Writer, pv
 	mcount := len(msg.DCMix)
 	if !hashing &amp;&amp; mcount == 0 {
 		msg := fmt.Sprintf(&quot;too few mixed messages [%v]&quot;, mcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if !hashing &amp;&amp; mcount &gt; MaxMixMcount {
 		msg := fmt.Sprintf(&quot;too many total mixed messages [%v]&quot;, mcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	kpcount := len(msg.DCMix[0])
 	if !hashing &amp;&amp; kpcount == 0 {
 		msg := fmt.Sprintf(&quot;too few mixing peers [%v]&quot;, kpcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	if !hashing &amp;&amp; kpcount &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many mixing peers [%v]&quot;, kpcount)
<span class="f1">-		return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 	err = WriteVarInt(w, pver, uint64(mcount))
 	if err != nil {
<span class="f6">@@ -212,13 +212,13 @@</span> func (msg *MsgMixSlotReserve) writeMessageNoSignature(op string, w io.Writer, pv
 	for i := range msg.DCMix {
 		if !hashing &amp;&amp; len(msg.DCMix[i]) != kpcount {
 			msg := &quot;invalid matrix dimensions&quot;
<span class="f1">-			return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>			<span class="f2">return messageError(op, msg)</span>
 		}
 		for j := range msg.DCMix[i] {
 			v := msg.DCMix[i][j]
 			if !hashing &amp;&amp; len(v) &gt; MaxMixFieldValLen {
 				msg := &quot;value exceeds bytes necessary to represent number in field&quot;
<span class="f1">-				return messageError(op, ErrInvalidMsg, msg)</span>
<span class="f2">+</span>				<span class="f2">return messageError(op, msg)</span>
 			}
 			err := WriteVarBytes(w, pver, v)
 			if err != nil {
<span class="f6">@@ -231,7 +231,7 @@</span> func (msg *MsgMixSlotReserve) writeMessageNoSignature(op string, w io.Writer, pv
 	if !hashing &amp;&amp; count &gt; MaxMixPeers {
 		msg := fmt.Sprintf(&quot;too many previous referenced messages [count %v, max %v]&quot;,
 			count, MaxMixPeers)
<span class="f1">-		return messageError(op, ErrTooManyPrevMixMsgs, msg)</span>
<span class="f2">+</span>		<span class="f2">return messageError(op, msg)</span>
 	}
 
 	err = WriteVarInt(w, pver, uint64(count))
<span class="bold">diff --git a/wire/msgmixslotreserve_test.go b/wire/msgmixslotreserve_test.go</span>
<span class="bold">index 070f7df6..b3841e9b 100644</span>
<span class="bold">--- a/wire/msgmixslotreserve_test.go</span>
<span class="bold">+++ b/wire/msgmixslotreserve_test.go</span>
<span class="f6">@@ -6,13 +6,13 @@</span> package wire
 
 import (
 	&quot;bytes&quot;
<span class="f1">-	&quot;errors&quot;</span>
 	&quot;fmt&quot;
 	&quot;reflect&quot;
<span class="f2">+</span>	<span class="f2">&quot;strings&quot;</span>
 	&quot;testing&quot;
 
<span class="f2">+</span>	<span class="f2">&quot;github.com/btcsuite/btcd/chaincfg/chainhash&quot;</span>
 	&quot;github.com/davecgh/go-spew/spew&quot;
<span class="f1">-	&quot;github.com/decred/dcrd/chaincfg/chainhash&quot;</span>
 )
 
 func newTestMixSlotReserve() *MsgMixSlotReserve {
<span class="f6">@@ -53,7 +53,7 @@</span> func TestMsgMixSlotReserveWire(t *testing.T) {
 	sr := newTestMixSlotReserve()
 
 	buf := new(bytes.Buffer)
<span class="f1">-	err := sr.BtcEncode(buf, pver)</span>
<span class="f2">+</span>	<span class="f2">err := sr.BtcEncode(buf, pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -107,7 +107,7 @@</span> func TestMsgMixSlotReserveWire(t *testing.T) {
 	expectedSerializationEqual(t, buf.Bytes(), expected)
 
 	decodedSR := new(MsgMixSlotReserve)
<span class="f1">-	err = decodedSR.BtcDecode(bytes.NewReader(buf.Bytes()), pver)</span>
<span class="f2">+</span>	<span class="f2">err = decodedSR.BtcDecode(bytes.NewReader(buf.Bytes()), pver, BaseEncoding)</span>
 	if err != nil {
 		t.Fatal(err)
 	}
<span class="f6">@@ -125,7 +125,7 @@</span> func TestMsgMixSlotReserveCrossProtocol(t *testing.T) {
 		name           string
 		encodeVersion  uint32
 		decodeVersion  uint32
<span class="f1">-		err            error</span>
<span class="f2">+</span>		<span class="f2">err            string</span>
 		remainingBytes int
 	}{{
 		name:          &quot;Latest-&gt;MixVersion&quot;,
<span class="f6">@@ -135,7 +135,7 @@</span> func TestMsgMixSlotReserveCrossProtocol(t *testing.T) {
 		name:          &quot;Latest-&gt;MixVersion-1&quot;,
 		encodeVersion: ProtocolVersion,
 		decodeVersion: MixVersion - 1,
<span class="f1">-		err:           ErrMsgInvalidForPVer,</span>
<span class="f2">+</span>		<span class="f2">err:           &quot;message invalid for protocol version&quot;,</span>
 	}, {
 		name:          &quot;MixVersion-&gt;Latest&quot;,
 		encodeVersion: MixVersion,
<span class="f6">@@ -147,7 +147,7 @@</span> func TestMsgMixSlotReserveCrossProtocol(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			t.Parallel()
 
<span class="f1">-			if tc.err != nil &amp;&amp; tc.remainingBytes != 0 {</span>
<span class="f2">+</span>			<span class="f2">if tc.err != &quot;&quot; &amp;&amp; tc.remainingBytes != 0 {</span>
 				t.Errorf(&quot;invalid testcase: non-zero remaining bytes &quot; +
 					&quot;expects no decoding error&quot;)
 			}
<span class="f6">@@ -155,14 +155,14 @@</span> func TestMsgMixSlotReserveCrossProtocol(t *testing.T) {
 			msg := newTestMixSlotReserve()
 
 			buf := new(bytes.Buffer)
<span class="f1">-			err := msg.BtcEncode(buf, tc.encodeVersion)</span>
<span class="f2">+</span>			<span class="f2">err := msg.BtcEncode(buf, tc.encodeVersion, BaseEncoding)</span>
 			if err != nil {
 				t.Fatalf(&quot;encode failed: %v&quot;, err)
 			}
 
 			msg = new(MsgMixSlotReserve)
<span class="f1">-			err = msg.BtcDecode(buf, tc.decodeVersion)</span>
<span class="f1">-			if !errors.Is(err, tc.err) {</span>
<span class="f2">+</span>			<span class="f2">err = msg.BtcDecode(buf, tc.decodeVersion, BaseEncoding)</span>
<span class="f2">+</span>			<span class="f2">if (err == nil &amp;&amp; tc.err != &quot;&quot;) || (err != nil &amp;&amp; !strings.Contains(err.Error(), tc.err)) {</span>
 				t.Errorf(&quot;decode failed; want %v, got %v&quot;, tc.err, err)
 			}
 			if err == nil &amp;&amp; buf.Len() != tc.remainingBytes {
</pre>
</body>
</html>
